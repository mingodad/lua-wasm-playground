; From tree-sitter-ada/src/grammar.json
; EBNF to generate grammar.js at
;      https://mingodad.github.io/lua-wasm-playground/
;      based on https://github.com/eatkins/tree-sitter-ebnf-generator
;      see also https://mingodad.github.io/plgh/json2ebnf.html

;*** maybe you'll need to search and replace this (:[a-zA-Z_]+)([?*+]) => $2$1


externals ::= {
	}

extras ::= {
	/\s|\\\r?\n/
	comment
	}

supertypes ::= {
	}

inline ::= {
	_name_not_function_call
	_name_for_component_choice
	}

conflicts ::= {
	{ null_procedure_declaration _subprogram_specification }
	{ expression_function_declaration _subprogram_specification }
	{ at_clause _name }
	{ slice _discrete_range }
	{ record_component_association_list positional_array_aggregate }
	{ value_sequence array_component_association }
	{ generic_instantiation procedure_specification }
	{ _defining_identifier_list object_renaming_declaration exception_renaming_declaration }
	{ _defining_identifier_list object_renaming_declaration }
	{ _defining_identifier_list object_renaming_declaration loop_label exception_renaming_declaration }
	{ _defining_identifier_list _name }
	{ generic_formal_part generic_renaming_declaration }
	{ derived_type_definition }
	{ full_type_declaration _discriminant_part }
	{ private_extension_declaration derived_type_definition }
	{ formal_derived_type_definition }
	{ _name _aspect_mark }
	{ _name package_body_stub }
	{ _name _subtype_indication }
	{ _name _subtype_indication component_choice_list }
	{ _name _subtype_mark }
	{ attribute_definition_clause _attribute_reference }
	{ component_choice_list discrete_choice }
	{ component_choice_list positional_array_aggregate }
	{ discriminant_association _parenthesized_expression }
	}

word ::= identifier

rules:

  compilation ::= compilation_unit*

  identifier ::= /[a-zA-Z\u{80}-\u{10FFFF}][0-9a-zA-Z_\u{80}-\u{10FFFF}]*/

  gnatprep_identifier ::= /\$[a-zA-Z\u{80}-\u{10FFFF}][0-9a-zA-Z_\u{80}-\u{10FFFF}]*/

  comment ::= @( '--' /.*/ )

  string_literal ::= @( /"(""|[^"])*"/ )

  character_literal ::= @( /'.'/ )

  numeric_literal ::= @( /[0-9][0-9_]*(\.[0-9_]+)?([eE][+-]?[0-9_]+)?/ | /[0-9]+#[0-9a-fA-F._-]+#([eE][+-]?[0-9_]+)?/ )

  git_conflict_mark ::= @( @(  2(  /[<<][<<][<<][<<][<<][<<][<<]/ )  ) -> "<<<<<<<" /.*/ )
	| @( @(  2(  /[>>][>>][>>][>>][>>][>>][>>]/ )  ) -> ">>>>>>>" /.*/ )
	| @( @(  2(  /[==][==][==][==][==][==][==]/ )  ) -> "=======" /.*/ )

  relational_operator ::= '='
	| '/='
	| '<'
	| '<='
	| '>'
	| '>='

  binary_adding_operator ::= '+'
	| '-'
	| '&'

  unary_adding_operator ::= '+'
	| '-'

  multiplying_operator ::= '*'
	| '/'
	| 'mod'
	| 'rem'

  tick ::= "'"

  _name_not_function_call ::= identifier
	| gnatprep_identifier
	| selected_component
	| _attribute_reference
	| qualified_expression
	| target_name
	| slice
	| character_literal
	| string_literal

  _name ::= _name_not_function_call
	| function_call

  _name_for_component_choice ::= identifier
	| string_literal

  _subtype_mark ::= identifier
	| selected_component
	| _attribute_reference

  selected_component ::= ( _name ):prefix '.' ( identifier | character_literal | string_literal ):selector_name

  target_name ::= '@'

  _name_list ::= _name ( ',' _name )*

  _defining_identifier_list ::= identifier ( ',' identifier )*

  slice ::= ( _name ):prefix '(' range_g ')'

  _attribute_reference ::= _name tick attribute_designator
	| _reduction_attribute_reference

  _reduction_attribute_reference ::= value_sequence tick reduction_attribute_designator

  reduction_attribute_designator ::= identifier '(' reduction_specification ')'

  reduction_specification ::= _name ',' expression

  value_sequence ::= '[' ( ( @(  2(  /[pP][aA][rR][aA][lL][lL][eE][lL]/ )  ) -> "parallel" ):is_parallel ( '(' chunk_specification ')' )? )? iterated_element_association ']'

  chunk_specification ::= _simple_expression
	| identifier @(  2(  /[iI][nN]/ )  ) -> "in" _discrete_subtype_definition

  iterated_element_association ::= @(  2(  /[fF][oO][rR]/ )  ) -> "for" ( loop_parameter_specification | iterator_specification ) ( @(  2(  /[uU][sS][eE]/ )  ) -> "use" expression )? '=>' expression

  _discrete_subtype_definition ::= _subtype_indication
	| range_g

  loop_parameter_specification ::= identifier @(  2(  /[iI][nN]/ )  ) -> "in" @(  2(  /[rR][eE][vV][eE][rR][sS][eE]/ )  ) -> "reverse"? _discrete_subtype_definition iterator_filter?

  _loop_parameter_subtype_indication ::= _subtype_indication
	| access_definition

  iterator_filter ::= @(  2(  /[wW][hH][eE][nN]/ )  ) -> "when" ( expression ):condition

  iterator_specification ::= identifier ( ':' _loop_parameter_subtype_indication )? ( @(  2(  /[iI][nN]/ )  ) -> "in" | @(  2(  /[oO][fF]/ )  ) -> "of" ) @(  2(  /[rR][eE][vV][eE][rR][sS][eE]/ )  ) -> "reverse"? ( _name ):iterator_name iterator_filter?

  attribute_designator ::= identifier
	| @(  2(  /[aA][cC][cC][eE][sS][sS]/ )  ) -> "access"
	| @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta"
	| @(  2(  /[dD][iI][gG][iI][tT][sS]/ )  ) -> "digits"
	| @(  2(  /[mM][oO][dD]/ )  ) -> "mod"

  qualified_expression ::= ( _name ):subtype_name tick ( _aggregate | _parenthesized_expression )

  compilation_unit ::= with_clause
	| @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private"? _declarative_item
	| _statement
	| subunit
	| entry_declaration

  _declarative_item ::= _basic_declarative_item
	| _proper_body
	| body_stub

  _basic_declarative_item ::= _basic_declaration
	| _aspect_clause
	| use_clause

  _basic_declaration ::= _type_declaration
	| subtype_declaration
	| object_declaration
	| number_declaration
	| subprogram_declaration
	| expression_function_declaration
	| null_procedure_declaration
	| package_declaration
	| _renaming_declaration
	| exception_declaration
	| _generic_declaration
	| generic_instantiation

  package_declaration ::= _package_specification ';'

  _package_specification ::= @(  2(  /[pP][aA][cC][kK][aA][gG][eE]/ )  ) -> "package" ( _name ):name aspect_specification? @(  2(  /[iI][sS]/ )  ) -> "is" _basic_declarative_item_pragma* ( @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private" _basic_declarative_item_pragma* )? @(  2(  /[eE][nN][dD]/ )  ) -> "end" ( _name )?:endname

  with_clause ::= ( @(  2(  /[lL][iI][mM][iI][tT][eE][dD]/ )  ) -> "limited" )?:is_limited ( @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private" )?:is_private @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" _name_list ';'

  use_clause ::= @(  2(  /[uU][sS][eE]/ )  ) -> "use" ( ( @(  2(  /[aA][lL][lL]/ )  ) -> "all" )?:is_all ( @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" ):is_type )? _name_list ';'

  subunit ::= @(  2(  /[sS][eE][pP][aA][rR][aA][tT][eE]/ )  ) -> "separate" '(' ( _name ):parent_unit_name ')' _proper_body

  _proper_body ::= subprogram_body
	| package_body
	| task_body
	| protected_body

  subprogram_body ::= overriding_indicator? _subprogram_specification aspect_specification? @(  2(  /[iI][sS]/ )  ) -> "is" non_empty_declarative_part? @(  2(  /[bB][eE][gG][iI][nN]/ )  ) -> "begin" handled_sequence_of_statements @(  2(  /[eE][nN][dD]/ )  ) -> "end" ( _name )?:endname ';'

  package_body ::= @(  2(  /[pP][aA][cC][kK][aA][gG][eE]/ )  ) -> "package" @(  2(  /[bB][oO][dD][yY]/ )  ) -> "body" ( _name ):name aspect_specification? @(  2(  /[iI][sS]/ )  ) -> "is" non_empty_declarative_part? ( @(  2(  /[bB][eE][gG][iI][nN]/ )  ) -> "begin" handled_sequence_of_statements )? @(  2(  /[eE][nN][dD]/ )  ) -> "end" ( _name )?:endname ';'

  _subtype_indication ::= null_exclusion? ( _name_not_function_call ):subtype_mark _constraint?

  discriminant_constraint ::= _parenthesized_expression
	| '(' discriminant_association ( ',' discriminant_association )* ')'

  discriminant_association ::= ( _name_for_component_choice ( '|' _name_for_component_choice )* '=>' )? expression

  _constraint ::= _scalar_constraint
	| index_constraint
	| discriminant_constraint

  _scalar_constraint ::= range_constraint
	| digits_constraint
	| delta_constraint

  range_g ::= ( ( _name ):prefix tick range_attribute_designator ):range_attribute_reference
	| _simple_expression '..' _simple_expression

  range_attribute_designator ::= @(  2(  /[rR][aA][nN][gG][eE]/ )  ) -> "range" ( '(' expression ')' )?

  range_constraint ::= @(  2(  /[rR][aA][nN][gG][eE]/ )  ) -> "range" range_g

  expression ::= _relation ( @(  2(  /[aA][nN][dD]/ )  ) -> "and" @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then"? _relation )*
	| _relation ( @(  2(  /[oO][rR]/ )  ) -> "or" @(  2(  /[eE][lL][sS][eE]/ )  ) -> "else"? _relation )*
	| _relation ( @(  2(  /[xX][oO][rR]/ )  ) -> "xor" _relation )*

  _relation ::= _simple_expression ( relational_operator _simple_expression )?
	| relation_membership
	| raise_expression

  relation_membership ::= _simple_expression @(  2(  /[nN][oO][tT]/ )  ) -> "not"? @(  2(  /[iI][nN]/ )  ) -> "in" membership_choice_list

  raise_expression ::=  >1(  @(  2(  /[rR][aA][iI][sS][eE]/ )  ) -> "raise" ( _name ):exception_name ( @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" _simple_expression )? )

  membership_choice_list ::= _membership_choice ( '|' _membership_choice )*

  _membership_choice ::= _simple_expression
	| range_g

  _simple_expression ::= unary_adding_operator? term ( binary_adding_operator term )*

  term ::= _factor ( multiplying_operator _factor )*

  _factor ::= _primary
	| factor_power
	| factor_abs
	| factor_not

  factor_power ::= ( _primary ):left '**' ( _primary ):right

  factor_abs ::= @(  2(  /[aA][bB][sS]/ )  ) -> "abs" _primary

  factor_not ::= @(  2(  /[nN][oO][tT]/ )  ) -> "not" _primary

  _parenthesized_expression ::= '(' ( expression | _conditional_expression | quantified_expression | declare_expression ) ')'

  _primary ::=  2(  numeric_literal | primary_null | _aggregate | ( _name ):name | allocator | _parenthesized_expression )

  primary_null ::= @(  2(  /[nN][uU][lL][lL]/ )  ) -> "null"

  allocator ::= @(  2(  /[nN][eE][wW]/ )  ) -> "new" subpool_specification? ( _subtype_indication_paren_constraint | qualified_expression )

  _subtype_indication_paren_constraint ::= null_exclusion? ( _subtype_mark ):subtype_mark (  ~1(  discriminant_constraint )  | index_constraint )?

  subpool_specification ::= '(' ( _name ):subpool_handle_name ')'

  _access_type_definition ::= null_exclusion? ( access_to_object_definition | access_to_subprogram_definition )

  access_to_subprogram_definition ::= @(  2(  /[aA][cC][cC][eE][sS][sS]/ )  ) -> "access" @(  2(  /[pP][rR][oO][tT][eE][cC][tT][eE][dD]/ )  ) -> "protected"? ( @(  2(  /[pP][rR][oO][cC][eE][dD][uU][rR][eE]/ )  ) -> "procedure" formal_part? | @(  2(  /[fF][uU][nN][cC][tT][iI][oO][nN]/ )  ) -> "function" _parameter_and_result_profile )

  access_to_object_definition ::= @(  2(  /[aA][cC][cC][eE][sS][sS]/ )  ) -> "access" general_access_modifier? _subtype_indication

  general_access_modifier ::= @(  2(  /[aA][lL][lL]/ )  ) -> "all"
	| @(  2(  /[cC][oO][nN][sS][tT][aA][nN][tT]/ )  ) -> "constant"

  access_definition ::= null_exclusion? @(  2(  /[aA][cC][cC][eE][sS][sS]/ )  ) -> "access" ( @(  2(  /[cC][oO][nN][sS][tT][aA][nN][tT]/ )  ) -> "constant"? ( _name ):subtype_mark | @(  2(  /[pP][rR][oO][tT][eE][cC][tT][eE][dD]/ )  ) -> "protected"? @(  2(  /[pP][rR][oO][cC][eE][dD][uU][rR][eE]/ )  ) -> "procedure" formal_part? | @(  2(  /[pP][rR][oO][tT][eE][cC][tT][eE][dD]/ )  ) -> "protected"? @(  2(  /[fF][uU][nN][cC][tT][iI][oO][nN]/ )  ) -> "function" _parameter_and_result_profile )

  actual_parameter_part ::= '(' ( parameter_association ( ',' parameter_association )* | _conditional_expression | quantified_expression | declare_expression ) ')'

  parameter_association ::= component_choice_list '=>' ( expression | '<>' )
	| expression
	| '<>'

  _conditional_expression ::= if_expression
	| case_expression

  _conditional_quantified_declare_expression ::= _conditional_expression
	| quantified_expression
	| declare_expression

  quantified_expression ::= @(  2(  /[fF][oO][rR]/ )  ) -> "for" quantifier ( loop_parameter_specification | iterator_specification ) '=>' ( expression ):predicate

  declare_expression ::= @(  2(  /[dD][eE][cC][lL][aA][rR][eE]/ )  ) -> "declare" _declare_item* @(  2(  /[bB][eE][gG][iI][nN]/ )  ) -> "begin" expression

  _declare_item ::= object_declaration
	| object_renaming_declaration
	| pragma_g

  quantifier ::= @(  2(  /[aA][lL][lL]/ )  ) -> "all"
	| @(  2(  /[sS][oO][mM][eE]/ )  ) -> "some"

  case_expression ::= @(  2(  /[cC][aA][sS][eE]/ )  ) -> "case" expression @(  2(  /[iI][sS]/ )  ) -> "is" case_expression_alternative ( ',' case_expression_alternative )*

  case_expression_alternative ::= @(  2(  /[wW][hH][eE][nN]/ )  ) -> "when" discrete_choice_list '=>' expression

  component_choice_list ::= @(  2(  /[oO][tT][hH][eE][rR][sS]/ )  ) -> "others"
	|  ~1(  _name_for_component_choice )  ( '|'  ~1(  _name_for_component_choice )  )*

  _aggregate ::= record_aggregate
	| extension_aggregate
	| _array_aggregate
	| _delta_aggregate

  _delta_aggregate ::= record_delta_aggregate
	| array_delta_aggregate

  extension_aggregate ::= '(' expression @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" _record_component_association_list_or_expression ')'

  record_delta_aggregate ::= '(' expression @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta" _record_component_association_list_or_expression ')'

  array_delta_aggregate ::= '(' expression @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta" _array_component_association_list ')'
	| '[' expression @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta" _array_component_association_list ']'

  record_aggregate ::= '(' record_component_association_list ')'

  record_component_association_list ::= @(  2(  /[nN][uU][lL][lL]/ )  ) -> "null" @(  2(  /[rR][eE][cC][oO][rR][dD]/ )  ) -> "record"
	| expression ',' ( expression | _named_record_component_association ) ( ',' ( expression | _named_record_component_association ) )*
	| _named_record_component_association ( ',' _named_record_component_association )*

  _record_component_association_list_or_expression ::= record_component_association_list
	| expression

  _named_record_component_association ::= component_choice_list '=>' ( expression | '<>' )

  null_exclusion ::= @(  2(  /[nN][oO][tT]/ )  ) -> "not" @(  2(  /[nN][uU][lL][lL]/ )  ) -> "null"

  index_constraint ::= '(' _discrete_range ( ',' _discrete_range )* ')'

  digits_constraint ::= @(  2(  /[dD][iI][gG][iI][tT][sS]/ )  ) -> "digits" _simple_expression range_constraint?

  delta_constraint ::= @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta" _simple_expression range_constraint?

  _basic_declarative_item_pragma ::= _basic_declarative_item
	| pragma_g

  _type_declaration ::= full_type_declaration
	| incomplete_type_declaration
	| private_type_declaration
	| private_extension_declaration

  full_type_declaration ::= @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" identifier known_discriminant_part? @(  2(  /[iI][sS]/ )  ) -> "is" _type_definition aspect_specification? ';'
	| task_type_declaration
	| protected_type_declaration

  private_type_declaration ::= @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" identifier _discriminant_part? @(  2(  /[iI][sS]/ )  ) -> "is" ( @(  2(  /[aA][bB][sS][tT][rR][aA][cC][tT]/ )  ) -> "abstract"? @(  2(  /[tT][aA][gG][gG][eE][dD]/ )  ) -> "tagged" )? @(  2(  /[lL][iI][mM][iI][tT][eE][dD]/ )  ) -> "limited"? @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private" aspect_specification? ';'

  private_extension_declaration ::= @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" identifier _discriminant_part? @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[aA][bB][sS][tT][rR][aA][cC][tT]/ )  ) -> "abstract"? ( @(  2(  /[lL][iI][mM][iI][tT][eE][dD]/ )  ) -> "limited" | @(  2(  /[sS][yY][nN][cC][hH][rR][oO][nN][iI][zZ][eE][dD]/ )  ) -> "synchronized" )? @(  2(  /[nN][eE][wW]/ )  ) -> "new" _subtype_indication ( @(  2(  /[aA][nN][dD]/ )  ) -> "and" _interface_list )? @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private" aspect_specification? ';'

  _discriminant_part ::= known_discriminant_part
	| unknown_discriminant_part

  unknown_discriminant_part ::= '(' '<>' ')'

  known_discriminant_part ::= '(' discriminant_specification_list ')'

  incomplete_type_declaration ::= @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" identifier _discriminant_part? ( @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[tT][aA][gG][gG][eE][dD]/ )  ) -> "tagged" )? ';'

  discriminant_specification_list ::= discriminant_specification ( ';' discriminant_specification )*

  discriminant_specification ::= _defining_identifier_list ':' ( null_exclusion? ( _name ):subtype_mark | access_definition ) _assign_value? aspect_specification?

  _type_definition ::= enumeration_type_definition
	| _integer_type_definition
	| _real_type_definition
	| array_type_definition
	| record_type_definition
	| _access_type_definition
	| derived_type_definition
	| interface_type_definition

  array_type_definition ::= @(  2(  /[aA][rR][rR][aA][yY]/ )  ) -> "array" '(' ( _discrete_subtype_definition_list | _index_subtype_definition_list ) ')' @(  2(  /[oO][fF]/ )  ) -> "of" component_definition

  _discrete_subtype_definition_list ::= _discrete_subtype_definition ( ',' _discrete_subtype_definition )*

  _discrete_range ::= _subtype_indication
	| range_g

  _index_subtype_definition_list ::= index_subtype_definition ( ',' index_subtype_definition )*

  index_subtype_definition ::= ( _name ):subtype_mark @(  2(  /[rR][aA][nN][gG][eE]/ )  ) -> "range" '<>'

  enumeration_type_definition ::= '(' _enumeration_literal_list ')'

  _enumeration_literal_list ::= _enumeration_literal_specification ( ',' _enumeration_literal_specification )*

  _enumeration_literal_specification ::= identifier
	| character_literal

  _integer_type_definition ::= signed_integer_type_definition
	| modular_type_definition

  modular_type_definition ::= @(  2(  /[mM][oO][dD]/ )  ) -> "mod" expression

  _real_type_definition ::= floating_point_definition
	| _fixed_point_definition

  floating_point_definition ::= @(  2(  /[dD][iI][gG][iI][tT][sS]/ )  ) -> "digits" expression real_range_specification?

  real_range_specification ::= @(  2(  /[rR][aA][nN][gG][eE]/ )  ) -> "range" _simple_expression '..' _simple_expression

  _fixed_point_definition ::= ordinary_fixed_point_definition
	| decimal_fixed_point_definition

  decimal_fixed_point_definition ::= @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta" expression @(  2(  /[dD][iI][gG][iI][tT][sS]/ )  ) -> "digits" expression real_range_specification?

  ordinary_fixed_point_definition ::= @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta" expression real_range_specification

  signed_integer_type_definition ::= @(  2(  /[rR][aA][nN][gG][eE]/ )  ) -> "range" _simple_expression '..' _simple_expression

  derived_type_definition ::= @(  2(  /[aA][bB][sS][tT][rR][aA][cC][tT]/ )  ) -> "abstract"? @(  2(  /[lL][iI][mM][iI][tT][eE][dD]/ )  ) -> "limited"? @(  2(  /[nN][eE][wW]/ )  ) -> "new" _subtype_indication ( ( @(  2(  /[aA][nN][dD]/ )  ) -> "and" _interface_list )? record_extension_part )?

  interface_type_definition ::= ( @(  2(  /[lL][iI][mM][iI][tT][eE][dD]/ )  ) -> "limited" | @(  2(  /[tT][aA][sS][kK]/ )  ) -> "task" | @(  2(  /[pP][rR][oO][tT][eE][cC][tT][eE][dD]/ )  ) -> "protected" | @(  2(  /[sS][yY][nN][cC][hH][rR][oO][nN][iI][zZ][eE][dD]/ )  ) -> "synchronized" )? @(  2(  /[iI][nN][tT][eE][rR][fF][aA][cC][eE]/ )  ) -> "interface" ( @(  2(  /[aA][nN][dD]/ )  ) -> "and" _interface_list )?

  _interface_list ::= _name ( @(  2(  /[aA][nN][dD]/ )  ) -> "and" _name )*

  record_extension_part ::= @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" record_definition

  record_type_definition ::= ( @(  2(  /[aA][bB][sS][tT][rR][aA][cC][tT]/ )  ) -> "abstract"? @(  2(  /[tT][aA][gG][gG][eE][dD]/ )  ) -> "tagged" )? @(  2(  /[lL][iI][mM][iI][tT][eE][dD]/ )  ) -> "limited"? record_definition

  record_definition ::= @(  2(  /[rR][eE][cC][oO][rR][dD]/ )  ) -> "record" component_list @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[rR][eE][cC][oO][rR][dD]/ )  ) -> "record" identifier?
	| @(  2(  /[nN][uU][lL][lL]/ )  ) -> "null" @(  2(  /[rR][eE][cC][oO][rR][dD]/ )  ) -> "record"

  component_list ::= _component_item+
	| _component_item* variant_part
	| @(  2(  /[nN][uU][lL][lL]/ )  ) -> "null" @(  2(  /[;;]/ )  ) -> ";"

  _component_item ::= component_declaration
	| _aspect_clause
	| pragma_g

  component_declaration ::= _defining_identifier_list ':' component_definition _assign_value? aspect_specification? ';'

  component_definition ::= @(  2(  /[aA][lL][iI][aA][sS][eE][dD]/ )  ) -> "aliased"? ( _subtype_indication | access_definition )

  _array_aggregate ::= positional_array_aggregate
	| null_array_aggregate
	| named_array_aggregate

  positional_array_aggregate ::= '(' expression ','  <1(  expression ( ',' expression )* )  ')'
	| '(' expression ( ',' expression )* ',' @(  2(  /[oO][tT][hH][eE][rR][sS]/ )  ) -> "others" '=>' ( expression | '<>' ) ')'
	| '[' expression ( ',' expression )* ( ',' @(  2(  /[oO][tT][hH][eE][rR][sS]/ )  ) -> "others" '=>' ( expression | '<>' ) )? ']'

  null_array_aggregate ::= '[' ']'

  named_array_aggregate ::= '(' _array_component_association_list ')'
	| '[' _array_component_association_list ']'

  _array_component_association_list ::= array_component_association ( ',' array_component_association )*

  array_component_association ::= discrete_choice_list '=>' ( expression | '<>' )
	| iterated_element_association

  discrete_choice_list ::= discrete_choice ( '|' discrete_choice )*

  discrete_choice ::=  ~1(  expression )
	| _subtype_indication
	| range_g
	| @(  2(  /[oO][tT][hH][eE][rR][sS]/ )  ) -> "others"

  aspect_association ::= _aspect_mark ( '=>' _aspect_definition )?

  _aspect_clause ::= attribute_definition_clause
	| enumeration_representation_clause
	| record_representation_clause
	| at_clause

  _aspect_definition ::= expression
	| global_aspect_definition

  _aspect_mark ::= identifier ( tick @(  2(  /[CC][lL][aA][sS][sS]/ )  ) -> "Class" )?

  aspect_mark_list ::= aspect_association ( ',' aspect_association )*

  aspect_specification ::= @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" aspect_mark_list

  _assign_value ::= ':=' expression

  at_clause ::= @(  2(  /[fF][oO][rR]/ )  ) -> "for" identifier @(  2(  /[uU][sS][eE]/ )  ) -> "use" @(  2(  /[aA][tT]/ )  ) -> "at" expression ';'

  attribute_definition_clause ::= @(  2(  /[fF][oO][rR]/ )  ) -> "for" ( _name ):local_name tick attribute_designator @(  2(  /[uU][sS][eE]/ )  ) -> "use" expression ';'

  body_stub ::= subprogram_body_stub
	| package_body_stub
	| task_body_stub
	| protected_body_stub

  subprogram_body_stub ::= overriding_indicator? _subprogram_specification @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[sS][eE][pP][aA][rR][aA][tT][eE]/ )  ) -> "separate" aspect_specification? ';'

  package_body_stub ::= @(  2(  /[pP][aA][cC][kK][aA][gG][eE]/ )  ) -> "package" @(  2(  /[bB][oO][dD][yY]/ )  ) -> "body" identifier @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[sS][eE][pP][aA][rR][aA][tT][eE]/ )  ) -> "separate" aspect_specification? ';'

  task_body ::= @(  2(  /[tT][aA][sS][kK]/ )  ) -> "task" @(  2(  /[bB][oO][dD][yY]/ )  ) -> "body" identifier aspect_specification? @(  2(  /[iI][sS]/ )  ) -> "is" non_empty_declarative_part? @(  2(  /[bB][eE][gG][iI][nN]/ )  ) -> "begin" handled_sequence_of_statements @(  2(  /[eE][nN][dD]/ )  ) -> "end" identifier? ';'

  task_body_stub ::= @(  2(  /[tT][aA][sS][kK]/ )  ) -> "task" @(  2(  /[bB][oO][dD][yY]/ )  ) -> "body" identifier @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[sS][eE][pP][aA][rR][aA][tT][eE]/ )  ) -> "separate" aspect_specification? ';'

  _protected_operation_declaration ::= subprogram_declaration
	| pragma_g
	| entry_declaration
	| _aspect_clause

  _protected_element_declaration ::= _protected_operation_declaration
	| component_declaration

  _protected_operation_item ::= subprogram_declaration
	| subprogram_body
	| null_procedure_declaration
	| expression_function_declaration
	| entry_body
	| _aspect_clause

  protected_definition ::= _protected_operation_declaration* ( @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private" _protected_element_declaration* )? @(  2(  /[eE][nN][dD]/ )  ) -> "end" identifier?

  protected_type_declaration ::= @(  2(  /[pP][rR][oO][tT][eE][cC][tT][eE][dD]/ )  ) -> "protected" @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" identifier known_discriminant_part? aspect_specification? @(  2(  /[iI][sS]/ )  ) -> "is" ( @(  2(  /[nN][eE][wW]/ )  ) -> "new" _interface_list @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" )? protected_definition ';'

  single_protected_declaration ::= @(  2(  /[pP][rR][oO][tT][eE][cC][tT][eE][dD]/ )  ) -> "protected" identifier aspect_specification? @(  2(  /[iI][sS]/ )  ) -> "is" ( @(  2(  /[nN][eE][wW]/ )  ) -> "new" _interface_list @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" )? protected_definition ';'

  protected_body ::= @(  2(  /[pP][rR][oO][tT][eE][cC][tT][eE][dD]/ )  ) -> "protected" @(  2(  /[bB][oO][dD][yY]/ )  ) -> "body" identifier aspect_specification? @(  2(  /[iI][sS]/ )  ) -> "is" _protected_operation_item* @(  2(  /[eE][nN][dD]/ )  ) -> "end" identifier? ';'

  protected_body_stub ::= @(  2(  /[pP][rR][oO][tT][eE][cC][tT][eE][dD]/ )  ) -> "protected" @(  2(  /[bB][oO][dD][yY]/ )  ) -> "body" identifier @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[sS][eE][pP][aA][rR][aA][tT][eE]/ )  ) -> "separate" aspect_specification? ';'

  choice_parameter_specification ::= identifier

  component_clause ::= ( _name ):local_name @(  2(  /[aA][tT]/ )  ) -> "at" ( expression ):position @(  2(  /[rR][aA][nN][gG][eE]/ )  ) -> "range" ( _simple_expression ):first_bit '..' ( _simple_expression ):last_bit ';'

  _declarative_item_pragma ::= _declarative_item
	| pragma_g
	| gnatprep_declarative_if_statement

  non_empty_declarative_part ::= _declarative_item_pragma+

  entry_declaration ::= overriding_indicator? @(  2(  /[eE][nN][tT][rR][yY]/ )  ) -> "entry" ( identifier ):entry_name ( '(' _discrete_subtype_definition ')' )? ( formal_part )?:parameter_profile aspect_specification? ';'

  entry_body ::= @(  2(  /[eE][nN][tT][rR][yY]/ )  ) -> "entry" identifier ( '(' entry_index_specification ')' )? ( formal_part )?:parameter_profile aspect_specification? entry_barrier @(  2(  /[iI][sS]/ )  ) -> "is" non_empty_declarative_part? @(  2(  /[bB][eE][gG][iI][nN]/ )  ) -> "begin" handled_sequence_of_statements @(  2(  /[eE][nN][dD]/ )  ) -> "end" identifier? ';'

  entry_barrier ::= @(  2(  /[wW][hH][eE][nN]/ )  ) -> "when" ( expression ):condition

  entry_index_specification ::= @(  2(  /[fF][oO][rR]/ )  ) -> "for" identifier @(  2(  /[iI][nN]/ )  ) -> "in" _discrete_subtype_definition aspect_specification?

  enumeration_aggregate ::= _array_aggregate

  enumeration_representation_clause ::= @(  2(  /[fF][oO][rR]/ )  ) -> "for" ( _name ):local_name @(  2(  /[uU][sS][eE]/ )  ) -> "use" enumeration_aggregate ';'

  exception_choice_list ::= exception_choice ( '|' exception_choice )*

  exception_choice ::= ( _name ):exception_name
	| @(  2(  /[oO][tT][hH][eE][rR][sS]/ )  ) -> "others"

  exception_declaration ::= _defining_identifier_list ':' @(  2(  /[eE][xX][cC][eE][pP][tT][iI][oO][nN]/ )  ) -> "exception" aspect_specification? ';'

  exception_handler ::= @(  2(  /[wW][hH][eE][nN]/ )  ) -> "when" ( choice_parameter_specification ':' )? exception_choice_list '=>' _sequence_of_statements

  formal_part ::= '(' _parameter_specification_list ')'

  function_specification ::= @(  2(  /[fF][uU][nN][cC][tT][iI][oO][nN]/ )  ) -> "function" ( _name ):name _parameter_and_result_profile

  _generic_declaration ::= generic_subprogram_declaration
	| generic_package_declaration

  generic_formal_part ::= @(  2(  /[gG][eE][nN][eE][rR][iI][cC]/ )  ) -> "generic" _generic_formal_parameter_declaration*

  _generic_formal_parameter_declaration ::= formal_object_declaration
	| _formal_type_declaration
	| formal_subprogram_declaration
	| formal_package_declaration
	| use_clause
	| pragma_g

  generic_subprogram_declaration ::= generic_formal_part _subprogram_specification aspect_specification? ';'

  generic_package_declaration ::= generic_formal_part package_declaration

  generic_instantiation ::= ( @(  2(  /[pP][aA][cC][kK][aA][gG][eE]/ )  ) -> "package" ( _name ):name | overriding_indicator? ( @(  2(  /[pP][rR][oO][cC][eE][dD][uU][rR][eE]/ )  ) -> "procedure" ( _name ):name | @(  2(  /[fF][uU][nN][cC][tT][iI][oO][nN]/ )  ) -> "function" ( _name ):name ) ) @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[nN][eE][wW]/ )  ) -> "new" ( _name ):generic_name aspect_specification? ';'

  formal_object_declaration ::= ( _defining_identifier_list ):name ':' non_empty_mode? null_exclusion? ( _name ):subtype_mark _assign_value? aspect_specification? ';'
	| _defining_identifier_list ':' non_empty_mode? access_definition _assign_value? aspect_specification? ';'

  _formal_type_declaration ::= formal_complete_type_declaration
	| formal_incomplete_type_declaration

  formal_complete_type_declaration ::= @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" identifier _discriminant_part? @(  2(  /[iI][sS]/ )  ) -> "is" _formal_type_definition ( @(  2(  /[oO][rR]/ )  ) -> "or" @(  2(  /[uU][sS][eE]/ )  ) -> "use" ( _name ):default_subtype_mark )? aspect_specification? ';'

  formal_incomplete_type_declaration ::= @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" identifier _discriminant_part? ( @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[tT][aA][gG][gG][eE][dD]/ )  ) -> "tagged" )? ( @(  2(  /[oO][rR]/ )  ) -> "or" @(  2(  /[uU][sS][eE]/ )  ) -> "use" ( _name ):default_subtype_mark )? ';'

  _formal_type_definition ::= formal_private_type_definition
	| formal_derived_type_definition
	| formal_discrete_type_definition
	| formal_signed_integer_type_definition
	| formal_modular_type_definition
	| formal_floating_point_definition
	| formal_ordinary_fixed_point_definition
	| formal_decimal_fixed_point_definition
	| formal_array_type_definition
	| formal_access_type_definition
	| formal_interface_type_definition

  formal_private_type_definition ::= ( @(  2(  /[aA][bB][sS][tT][rR][aA][cC][tT]/ )  ) -> "abstract"? @(  2(  /[tT][aA][gG][gG][eE][dD]/ )  ) -> "tagged" )? @(  2(  /[lL][iI][mM][iI][tT][eE][dD]/ )  ) -> "limited"? @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private"

  formal_derived_type_definition ::= @(  2(  /[aA][bB][sS][tT][rR][aA][cC][tT]/ )  ) -> "abstract"? ( @(  2(  /[lL][iI][mM][iI][tT][eE][dD]/ )  ) -> "limited" | @(  2(  /[sS][yY][nN][cC][hH][rR][oO][nN][iI][zZ][eE][dD]/ )  ) -> "synchronized" )? @(  2(  /[nN][eE][wW]/ )  ) -> "new" ( _name ):subtype_mark ( ( @(  2(  /[aA][nN][dD]/ )  ) -> "and" _interface_list )? @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private" )?

  formal_discrete_type_definition ::= '(' '<>' ')'

  formal_signed_integer_type_definition ::= @(  2(  /[rR][aA][nN][gG][eE]/ )  ) -> "range" '<>'

  formal_modular_type_definition ::= @(  2(  /[mM][oO][dD]/ )  ) -> "mod" '<>'

  formal_floating_point_definition ::= @(  2(  /[dD][iI][gG][iI][tT][sS]/ )  ) -> "digits" '<>'

  formal_ordinary_fixed_point_definition ::= @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta" '<>'

  formal_decimal_fixed_point_definition ::= @(  2(  /[dD][eE][lL][tT][aA]/ )  ) -> "delta" '<>' @(  2(  /[dD][iI][gG][iI][tT][sS]/ )  ) -> "digits" '<>'

  formal_array_type_definition ::= array_type_definition

  formal_access_type_definition ::= _access_type_definition

  formal_interface_type_definition ::= interface_type_definition

  formal_subprogram_declaration ::= formal_concrete_subprogram_declaration
	| formal_abstract_subprogram_declaration

  formal_concrete_subprogram_declaration ::= @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" _subprogram_specification ( @(  2(  /[iI][sS]/ )  ) -> "is" subprogram_default )? aspect_specification? ';'

  formal_abstract_subprogram_declaration ::= @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" _subprogram_specification @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[aA][bB][sS][tT][rR][aA][cC][tT]/ )  ) -> "abstract" subprogram_default? aspect_specification? ';'

  subprogram_default ::= ( _name ):default_name
	| '<>'
	| @(  2(  /[nN][uU][lL][lL]/ )  ) -> "null"

  formal_package_declaration ::= @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" @(  2(  /[pP][aA][cC][kK][aA][gG][eE]/ )  ) -> "package" identifier @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[nN][eE][wW]/ )  ) -> "new" ( _name ):generic_package_name aspect_specification? ';'

  formal_group_designator ::= 'null'
	| 'all'

  extended_global_aspect_element ::= @(  2(  /[uU][sS][eE]/ )  ) -> "use" ( formal_group_designator | _name ( ',' _name )* ):formal_parameter_set

  global_aspect_definition ::= global_mode
	| '(' global_aspect_element ( ',' global_aspect_element )* ')'

  global_aspect_element ::= global_mode ( _name_list ):global_set

  global_mode ::= non_empty_mode
	| @(  2(  /[oO][vV][eE][rR][rR][iI][dD][iI][nN][gG]/ )  ) -> "overriding"

  handled_sequence_of_statements ::= _sequence_of_statements ( @(  2(  /[eE][xX][cC][eE][pP][tT][iI][oO][nN]/ )  ) -> "exception" exception_handler+ )?

  loop_label ::= ( identifier ):statement_identifier ':'

  label ::= '<<' ( identifier ):statement_identifier '>>'

  mod_clause ::= @(  2(  /[aA][tT]/ )  ) -> "at" @(  2(  /[mM][oO][dD]/ )  ) -> "mod" expression ';'

  non_empty_mode ::= @(  2(  /[iI][nN]/ )  ) -> "in"
	| @(  2(  /[iI][nN]/ )  ) -> "in" @(  2(  /[oO][uU][tT]/ )  ) -> "out"
	| @(  2(  /[oO][uU][tT]/ )  ) -> "out"

  null_procedure_declaration ::= overriding_indicator? procedure_specification @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[nN][uU][lL][lL]/ )  ) -> "null" aspect_specification? ';'

  null_statement ::= @(  2(  /[nN][uU][lL][lL]/ )  ) -> "null" ';'

  number_declaration ::= _defining_identifier_list ':' @(  2(  /[cC][oO][nN][sS][tT][aA][nN][tT]/ )  ) -> "constant" _assign_value ';'

  object_declaration ::= ( _defining_identifier_list ):name ':' @(  2(  /[aA][lL][iI][aA][sS][eE][dD]/ )  ) -> "aliased"? @(  2(  /[cC][oO][nN][sS][tT][aA][nN][tT]/ )  ) -> "constant"? ( _subtype_indication | access_definition | array_type_definition ) _assign_value? aspect_specification? ';'
	| single_task_declaration
	| single_protected_declaration

  single_task_declaration ::= @(  2(  /[tT][aA][sS][kK]/ )  ) -> "task" identifier aspect_specification? ( @(  2(  /[iI][sS]/ )  ) -> "is" ( @(  2(  /[nN][eE][wW]/ )  ) -> "new" _interface_list @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" )? task_definition )? ';'

  task_type_declaration ::= @(  2(  /[tT][aA][sS][kK]/ )  ) -> "task" @(  2(  /[tT][yY][pP][eE]/ )  ) -> "type" identifier known_discriminant_part? aspect_specification? ( @(  2(  /[iI][sS]/ )  ) -> "is" ( @(  2(  /[nN][eE][wW]/ )  ) -> "new" _interface_list @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" )? task_definition )? ';'

  _task_item ::= entry_declaration
	| _aspect_clause
	| pragma_g

  task_definition ::= _task_item* ( @(  2(  /[pP][rR][iI][vV][aA][tT][eE]/ )  ) -> "private" _task_item* )? @(  2(  /[eE][nN][dD]/ )  ) -> "end" ( identifier )?:endname

  overriding_indicator ::= @(  2(  /[nN][oO][tT]/ )  ) -> "not"? @(  2(  /[oO][vV][eE][rR][rR][iI][dD][iI][nN][gG]/ )  ) -> "overriding"

  _parameter_and_result_profile ::= formal_part? result_profile

  parameter_specification ::= _defining_identifier_list ':' ( @(  2(  /[aA][lL][iI][aA][sS][eE][dD]/ )  ) -> "aliased"? non_empty_mode? null_exclusion? ( _name ):subtype_mark | access_definition ) _assign_value? aspect_specification?

  _parameter_specification_list ::= parameter_specification ( ';' parameter_specification )*

  pragma_g ::= @(  2(  /[pP][rR][aA][gG][mM][aA]/ )  ) -> "pragma" identifier ( '(' ( pragma_argument_association ( ',' pragma_argument_association )* | _conditional_quantified_declare_expression ) ')' )? ';'

  pragma_argument_association ::= ( _aspect_mark '=>' )? expression

  if_expression ::= @(  2(  /[iI][fF]/ )  ) -> "if" ( expression ):condition @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" expression elsif_expression_item* ( @(  2(  /[eE][lL][sS][eE]/ )  ) -> "else" expression )?

  elsif_expression_item ::= @(  2(  /[eE][lL][sS][iI][fF]/ )  ) -> "elsif" ( expression ):condition @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" expression

  procedure_specification ::= @(  2(  /[pP][rR][oO][cC][eE][dD][uU][rR][eE]/ )  ) -> "procedure" ( _name ):name formal_part?

  record_representation_clause ::= @(  2(  /[fF][oO][rR]/ )  ) -> "for" ( _name ):local_name @(  2(  /[uU][sS][eE]/ )  ) -> "use" @(  2(  /[rR][eE][cC][oO][rR][dD]/ )  ) -> "record" mod_clause? component_clause* @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[rR][eE][cC][oO][rR][dD]/ )  ) -> "record" ( _name )?:end_local_name ';'

  _renaming_declaration ::= object_renaming_declaration
	| exception_renaming_declaration
	| package_renaming_declaration
	| subprogram_renaming_declaration
	| generic_renaming_declaration

  object_renaming_declaration ::= identifier ( ':' null_exclusion? ( _name ):subtype_mark )? @(  2(  /[rR][eE][nN][aA][mM][eE][sS]/ )  ) -> "renames" ( _name ):object_name aspect_specification? ';'
	| identifier ':' access_definition @(  2(  /[rR][eE][nN][aA][mM][eE][sS]/ )  ) -> "renames" ( _name ):object_name aspect_specification? ';'

  exception_renaming_declaration ::= identifier ':' @(  2(  /[eE][xX][cC][eE][pP][tT][iI][oO][nN]/ )  ) -> "exception" @(  2(  /[rR][eE][nN][aA][mM][eE][sS]/ )  ) -> "renames" ( _name ):exception_name aspect_specification? ';'

  package_renaming_declaration ::= @(  2(  /[pP][aA][cC][kK][aA][gG][eE]/ )  ) -> "package" ( _name ):name @(  2(  /[rR][eE][nN][aA][mM][eE][sS]/ )  ) -> "renames" ( _name ):package_name aspect_specification? ';'

  subprogram_renaming_declaration ::= overriding_indicator? _subprogram_specification @(  2(  /[rR][eE][nN][aA][mM][eE][sS]/ )  ) -> "renames" ( _name ):callable_entity_name aspect_specification? ';'

  generic_renaming_declaration ::= @(  2(  /[gG][eE][nN][eE][rR][iI][cC]/ )  ) -> "generic" @(  2(  /[pP][aA][cC][kK][aA][gG][eE]/ )  ) -> "package" ( _name ):defining_program_unit_name @(  2(  /[rR][eE][nN][aA][mM][eE][sS]/ )  ) -> "renames" ( _name ):generic_package_name aspect_specification? ';'
	| @(  2(  /[gG][eE][nN][eE][rR][iI][cC]/ )  ) -> "generic" @(  2(  /[pP][rR][oO][cC][eE][dD][uU][rR][eE]/ )  ) -> "procedure" ( _name ):defining_program_unit_name @(  2(  /[rR][eE][nN][aA][mM][eE][sS]/ )  ) -> "renames" ( _name ):generic_procedure_name aspect_specification? ';'
	| @(  2(  /[gG][eE][nN][eE][rR][iI][cC]/ )  ) -> "generic" @(  2(  /[fF][uU][nN][cC][tT][iI][oO][nN]/ )  ) -> "function" ( _name ):defining_program_unit_name @(  2(  /[rR][eE][nN][aA][mM][eE][sS]/ )  ) -> "renames" ( _name ):generic_function_name aspect_specification? ';'

  result_profile ::= @(  2(  /[rR][eE][tT][uU][rR][nN]/ )  ) -> "return" ( null_exclusion? ( _name ):subtype_mark | access_definition )

  _sequence_of_statements ::= _statement+ label*

  _simple_statement ::= null_statement
	| assignment_statement
	| exit_statement
	| goto_statement
	| procedure_call_statement
	| simple_return_statement
	| requeue_statement
	| _delay_statement
	| abort_statement
	| raise_statement
	| pragma_g

  _statement ::= label* ( _simple_statement | _compound_statement )

  _compound_statement ::= if_statement
	| gnatprep_if_statement
	| case_statement
	| loop_statement
	| block_statement
	| extended_return_statement
	| accept_statement
	| _select_statement

  _select_statement ::= selective_accept
	| timed_entry_call
	| conditional_entry_call
	| asynchronous_select

  entry_call_alternative ::= procedure_call_statement _sequence_of_statements?

  asynchronous_select ::= @(  2(  /[sS][eE][lL][eE][cC][tT]/ )  ) -> "select" triggering_alternative @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" @(  2(  /[aA][bB][oO][rR][tT]/ )  ) -> "abort" ( _sequence_of_statements ):abortable_part @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[sS][eE][lL][eE][cC][tT]/ )  ) -> "select" ';'

  triggering_alternative ::= procedure_call_statement _sequence_of_statements?
	| _delay_statement _sequence_of_statements?

  conditional_entry_call ::= @(  2(  /[sS][eE][lL][eE][cC][tT]/ )  ) -> "select" entry_call_alternative @(  2(  /[eE][lL][sS][eE]/ )  ) -> "else" _sequence_of_statements @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[sS][eE][lL][eE][cC][tT]/ )  ) -> "select" ';'

  delay_alternative ::= _delay_statement _sequence_of_statements?

  timed_entry_call ::= @(  2(  /[sS][eE][lL][eE][cC][tT]/ )  ) -> "select" entry_call_alternative @(  2(  /[oO][rR]/ )  ) -> "or" delay_alternative @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[sS][eE][lL][eE][cC][tT]/ )  ) -> "select" ';'

  guard ::= @(  2(  /[wW][hH][eE][nN]/ )  ) -> "when" ( expression ):condition '=>'

  select_alternative ::= accept_alternative
	| delay_alternative
	| terminate_alternative

  accept_alternative ::= accept_statement _sequence_of_statements?

  terminate_alternative ::= @(  2(  /[tT][eE][rR][mM][iI][nN][aA][tT][eE]/ )  ) -> "terminate" ';'

  selective_accept ::= @(  2(  /[sS][eE][lL][eE][cC][tT]/ )  ) -> "select" guard? select_alternative ( @(  2(  /[oO][rR]/ )  ) -> "or" guard? select_alternative )* ( @(  2(  /[eE][lL][sS][eE]/ )  ) -> "else" _sequence_of_statements )? @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[sS][eE][lL][eE][cC][tT]/ )  ) -> "select" ';'

  abort_statement ::= @(  2(  /[aA][bB][oO][rR][tT]/ )  ) -> "abort" _name ( ',' _name )* ';'

  requeue_statement ::= @(  2(  /[rR][eE][qQ][uU][eE][uU][eE]/ )  ) -> "requeue" ( _name ):name ( @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" @(  2(  /[aA][bB][oO][rR][tT]/ )  ) -> "abort" )? ';'

  accept_statement ::= @(  2(  /[aA][cC][cC][eE][pP][tT]/ )  ) -> "accept" ( identifier ):entry_direct_name ( '(' ( expression ):entry_index ')' )? ( formal_part )?:parameter_profile ( @(  2(  /[dD][oO]/ )  ) -> "do" handled_sequence_of_statements @(  2(  /[eE][nN][dD]/ )  ) -> "end" ( identifier )?:entry_identifier )? ';'

  case_statement_alternative ::= @(  2(  /[wW][hH][eE][nN]/ )  ) -> "when" discrete_choice_list '=>' _sequence_of_statements

  case_statement ::= @(  2(  /[cC][aA][sS][eE]/ )  ) -> "case" expression @(  2(  /[iI][sS]/ )  ) -> "is" case_statement_alternative+ @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[cC][aA][sS][eE]/ )  ) -> "case" ';'

  block_statement ::= loop_label? ( @(  2(  /[dD][eE][cC][lL][aA][rR][eE]/ )  ) -> "declare" non_empty_declarative_part? )? @(  2(  /[bB][eE][gG][iI][nN]/ )  ) -> "begin" handled_sequence_of_statements @(  2(  /[eE][nN][dD]/ )  ) -> "end" identifier? ';'

  if_statement ::= @(  2(  /[iI][fF]/ )  ) -> "if" ( expression ):condition @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" ( _sequence_of_statements ):statements elsif_statement_item* ( @(  2(  /[eE][lL][sS][eE]/ )  ) -> "else" ( _sequence_of_statements ):else_statements )? @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[iI][fF]/ )  ) -> "if" ';'

  elsif_statement_item ::= @(  2(  /[eE][lL][sS][iI][fF]/ )  ) -> "elsif" ( expression ):condition @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" ( _sequence_of_statements ):statements

  gnatprep_declarative_if_statement ::= @(  2(  /[##][iI][fF]/ )  ) -> "#if" ( expression ):condition @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" _declarative_item_pragma* ( @(  2(  /[##][eE][lL][sS][iI][fF]/ )  ) -> "#elsif" ( expression ):condition @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" _declarative_item_pragma* )* ( @(  2(  /[##][eE][lL][sS][eE]/ )  ) -> "#else" _declarative_item_pragma* )? @(  2(  /[##][eE][nN][dD]/ )  ) -> "#end" @(  2(  /[iI][fF]/ )  ) -> "if" ';'

  gnatprep_if_statement ::= @(  2(  /[##][iI][fF]/ )  ) -> "#if" ( expression ):condition @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" _statement* ( @(  2(  /[##][eE][lL][sS][iI][fF]/ )  ) -> "#elsif" ( expression ):condition @(  2(  /[tT][hH][eE][nN]/ )  ) -> "then" _statement* )* ( @(  2(  /[##][eE][lL][sS][eE]/ )  ) -> "#else" _statement* )? @(  2(  /[##][eE][nN][dD]/ )  ) -> "#end" @(  2(  /[iI][fF]/ )  ) -> "if" ';'

  exit_statement ::= @(  2(  /[eE][xX][iI][tT]/ )  ) -> "exit" ( _name )?:loop_name ( @(  2(  /[wW][hH][eE][nN]/ )  ) -> "when" ( expression ):condition )? ';'

  goto_statement ::= @(  2(  /[gG][oO][tT][oO]/ )  ) -> "goto" ( _name ):label_name ';'

  _delay_statement ::= delay_until_statement
	| delay_relative_statement

  delay_until_statement ::= @(  2(  /[dD][eE][lL][aA][yY]/ )  ) -> "delay" @(  2(  /[uU][nN][tT][iI][lL]/ )  ) -> "until" expression ';'

  delay_relative_statement ::= @(  2(  /[dD][eE][lL][aA][yY]/ )  ) -> "delay" expression ';'

  simple_return_statement ::= @(  2(  /[rR][eE][tT][uU][rR][nN]/ )  ) -> "return" expression? ';'

  extended_return_statement ::= @(  2(  /[rR][eE][tT][uU][rR][nN]/ )  ) -> "return" extended_return_object_declaration ( @(  2(  /[dD][oO]/ )  ) -> "do" handled_sequence_of_statements @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[rR][eE][tT][uU][rR][nN]/ )  ) -> "return" )? ';'

  extended_return_object_declaration ::= identifier ':' @(  2(  /[aA][lL][iI][aA][sS][eE][dD]/ )  ) -> "aliased"? @(  2(  /[cC][oO][nN][sS][tT][aA][nN][tT]/ )  ) -> "constant"? _return_subtype_indication _assign_value? aspect_specification?

  _return_subtype_indication ::= _subtype_indication
	| access_definition

  procedure_call_statement ::= ( _name_not_function_call ):name ';'
	| ( _name ):name actual_parameter_part ';'

  function_call ::= ( _name ):name actual_parameter_part

  raise_statement ::= @(  2(  /[rR][aA][iI][sS][eE]/ )  ) -> "raise" ( ( _name ):name ( @(  2(  /[wW][iI][tT][hH]/ )  ) -> "with" expression )? )? ';'

  loop_statement ::= loop_label? iteration_scheme? @(  2(  /[lL][oO][oO][pP]/ )  ) -> "loop" ( _sequence_of_statements ):statements @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[lL][oO][oO][pP]/ )  ) -> "loop" identifier? ';'

  iteration_scheme ::= @(  2(  /[wW][hH][iI][lL][eE]/ )  ) -> "while" ( expression ):condition
	| @(  2(  /[fF][oO][rR]/ )  ) -> "for" ( loop_parameter_specification | iterator_specification )

  assignment_statement ::= ( _name ):variable_name _assign_value ';'

  subprogram_declaration ::= overriding_indicator? _subprogram_specification ( @(  2(  /[iI][sS]/ )  ) -> "is" @(  2(  /[aA][bB][sS][tT][rR][aA][cC][tT]/ )  ) -> "abstract" )?:is_abstract aspect_specification? ';'

  expression_function_declaration ::= overriding_indicator? function_specification @(  2(  /[iI][sS]/ )  ) -> "is" ( _aggregate | _parenthesized_expression ) aspect_specification? ';'

  _subprogram_specification ::= procedure_specification
	| function_specification

  subtype_declaration ::= @(  2(  /[sS][uU][bB][tT][yY][pP][eE]/ )  ) -> "subtype" identifier @(  2(  /[iI][sS]/ )  ) -> "is" _subtype_indication aspect_specification? ';'

  variant_part ::= @(  2(  /[cC][aA][sS][eE]/ )  ) -> "case" identifier @(  2(  /[iI][sS]/ )  ) -> "is" variant_list @(  2(  /[eE][nN][dD]/ )  ) -> "end" @(  2(  /[cC][aA][sS][eE]/ )  ) -> "case" ';'

  variant_list ::= variant+

  variant ::= @(  2(  /[wW][hH][eE][nN]/ )  ) -> "when" discrete_choice_list '=>' component_list
